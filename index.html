<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DuckDB Snippets Search</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
    <style>
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .search-container input {
            flex-grow: 1;
            min-width: 250px;
        }
        
        #loading {
            display: none;
            margin: 20px 0;
        }
        
        .progress-container {
            width: 100%;
            background-color: #eee;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #4299E1;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .snippet {
            border: 1px solid #ccc;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        .snippet h3 {
            margin-top: 0;
        }
        
        .snippet pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 400px;
        }
        
        .tag {
            display: inline-block;
            background-color: #e2e8f0;
            padding: 4px 8px;
            border-radius: 4px;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .tag.selected {
            background-color: #4299E1;
            color: white;
        }
        
        .meta {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        
        #stats {
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        .filters {
            margin-bottom: 20px;
        }
        
        #tags-container {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .copy-btn {
            float: right;
            padding: 5px 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .copy-btn:hover {
            background-color: #e5e5e5;
        }
        
        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
            }
            
            .search-container input, 
            .search-container button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>DuckDB Snippets Search</h1>
    
    <div class="search-container">
        <input type="text" id="search" placeholder="Search by keyword(s)">
        <button onclick="searchSnippets()">Search</button>
        <button onclick="clearSearch()">Clear</button>
    </div>
    
    <div class="filters">
        <details>
            <summary>Filter by Tags</summary>
            <div id="tags-container"></div>
        </details>
    </div>
    
    <div id="stats"></div>

    <div id="loading">
        <p id="loading-text">Loading snippets...</p>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
    
    <div id="results"></div>

    <script>
        // Configuration
        // Replace this with your actual Supabase Edge Function URL
        const PROXY_URL = 'https://nihgslsitmxrxljibnnm.supabase.co/functions/v1/proxy-duckdb-snippets';
        let buildId = ''; // Will be detected dynamically
        const totalPages = 11; // Based on your mention of 11 pages
        
        // State variables
        let allSnippets = [];
        let loadedPages = 0;
        let filteredSnippets = [];
        let allTags = new Set();
        let selectedTags = new Set();
        
        // Elements
        const loadingElement = document.getElementById('loading');
        const loadingTextElement = document.getElementById('loading-text');
        const progressBarElement = document.getElementById('progress-bar');
        const resultsElement = document.getElementById('results');
        const statsElement = document.getElementById('stats');
        const tagsContainerElement = document.getElementById('tags-container');
        
        // Initialize on page load
        window.onload = initializeApp;
        
        async function initializeApp() {
            showLoading(true);
            loadingTextElement.textContent = "Detecting current site version...";
            
            try {
                // First, detect the current buildId
                await detectBuildId();
                
                if (!buildId) {
                    throw new Error("Could not detect the site version (buildId)");
                }
                
                // Then fetch all snippets
                await fetchAllSnippets();
                
                // If we couldn't get any snippets, fall back to scraping
                if (allSnippets.length === 0) {
                    loadingTextElement.textContent = "Trying alternative method to load snippets...";
                    await fetchSnippetsByDirectScraping();
                }
            } catch (error) {
                console.error("Initialization error:", error);
                loadingElement.style.display = 'block';
                loadingTextElement.textContent = "Error: " + error.message;
                progressBarElement.style.backgroundColor = "#e53e3e";
                
                // Try direct scraping as a last resort
                try {
                    loadingTextElement.textContent = "Trying alternative method to load snippets...";
                    await fetchSnippetsByDirectScraping();
                } catch (scrapeError) {
                    console.error("Direct scraping also failed:", scrapeError);
                    loadingTextElement.textContent = "Could not load snippets. Please try again later.";
                }
            }
        }
        
        async function fetchSnippetsByDirectScraping() {
            updateProgress(0);
            allSnippets = [];
            loadedPages = 0;
            
            for (let page = 1; page <= totalPages; page++) {
                try {
                    const pageUrl = `https://duckdbsnippets.com/page/${page}/most-recent`;
                    const url = `${PROXY_URL}?url=${encodeURIComponent(pageUrl)}`;
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const html = await response.text();
                    
                    // Parse HTML to extract snippets
                    const pageSnippets = parseSnippetsFromHTML(html);
                    
                    if (pageSnippets.length > 0) {
                        allSnippets = [...allSnippets, ...pageSnippets];
                        console.log(`Scraped ${pageSnippets.length} snippets from page ${page}`);
                    } else {
                        console.warn(`No snippets found on page ${page}`);
                    }
                    
                    loadedPages++;
                    updateProgress((loadedPages / totalPages) * 100);
                    loadingTextElement.textContent = `Loading snippets... (${loadedPages}/${totalPages})`;
                } catch (error) {
                    console.error(`Error scraping page ${page}:`, error);
                }
            }
            
            if (allSnippets.length === 0) {
                throw new Error("Could not find any snippets through direct scraping");
            }
            
            // Extract all unique tags
            allTags = new Set();
            allSnippets.forEach(snippet => {
                if (snippet.tags && Array.isArray(snippet.tags)) {
                    snippet.tags.forEach(tag => allTags.add(tag));
                }
            });
            
            // Populate tags filter
            populateTagsFilter();
            
            showLoading(false);
            
            // Initial display without filtering
            filteredSnippets = [...allSnippets];
            displaySnippets(filteredSnippets);
        }
        
        function parseSnippetsFromHTML(html) {
            const snippets = [];
            
            // Create a temporary DOM element to parse the HTML
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Find all snippet containers
            const snippetElements = doc.querySelectorAll('.snippet, [class*="snippet"], [id*="snippet"], pre, code');
            
            snippetElements.forEach((element, index) => {
                try {
                    // Try to extract title, content, tags, etc.
                    const titleElement = element.querySelector('h2, h3, h4, .title, [class*="title"]');
                    const title = titleElement ? titleElement.textContent.trim() : `Snippet ${index + 1}`;
                    
                    // Try to get content from different potential elements
                    let content = '';
                    const codeElement = element.querySelector('pre, code, .code, [class*="code"]');
                    if (codeElement) {
                        content = codeElement.textContent.trim();
                    } else {
                        content = element.textContent.trim();
                    }
                    
                    // Try to extract tags
                    const tagElements = element.querySelectorAll('.tag, [class*="tag"]');
                    const tags = Array.from(tagElements).map(tag => tag.textContent.trim());
                    
                    // Try to extract author and date
                    const metaElement = element.querySelector('.meta, [class*="meta"], .info, [class*="info"]');
                    let author = '';
                    let createdAt = '';
                    
                    if (metaElement) {
                        const authorElement = metaElement.querySelector('[class*="author"]');
                        if (authorElement) {
                            author = authorElement.textContent.trim();
                        }
                        
                        const dateElement = metaElement.querySelector('[class*="date"], [datetime]');
                        if (dateElement) {
                            createdAt = dateElement.getAttribute('datetime') || dateElement.textContent.trim();
                        }
                    }
                    
                    snippets.push({
                        title,
                        content,
                        tags,
                        author,
                        createdAt
                    });
                } catch (error) {
                    console.error('Error parsing snippet:', error);
                }
            });
            
            return snippets;
        }
        
        async function detectBuildId() {
            try {
                // First try to get the buildId from the homepage
                const homePageUrl = "https://duckdbsnippets.com";
                const response = await fetch(`${PROXY_URL}?url=${encodeURIComponent(homePageUrl)}`);
                const html = await response.text();
                
                // Look for the buildId in the HTML
                // This pattern searches for the buildId in the Next.js script tags
                const buildIdRegex = /"buildId":"([^"]+)"/;
                const match = html.match(buildIdRegex);
                
                if (match && match[1]) {
                    buildId = match[1];
                    console.log("Detected buildId:", buildId);
                    return;
                }
                
                // If not found, try an alternative approach - get it from a known page's URL
                const pageUrl = "https://duckdbsnippets.com/page/1/most-recent";
                const pageResponse = await fetch(`${PROXY_URL}?url=${encodeURIComponent(pageUrl)}`);
                const pageHtml = await pageResponse.text();
                
                // Look for URLs that contain the buildId
                const urlRegex = /\/_next\/data\/([^\/]+)\/page\/1\/most-recent\.json/;
                const urlMatch = pageHtml.match(urlRegex);
                
                if (urlMatch && urlMatch[1]) {
                    buildId = urlMatch[1];
                    console.log("Detected buildId from URL:", buildId);
                    return;
                }
                
                // Final fallback - try to find any content that looks like a buildId
                const generalBuildIdRegex = /\/_next\/data\/([A-Za-z0-9_-]{8,})\//;
                const generalMatch = pageHtml.match(generalBuildIdRegex);
                
                if (generalMatch && generalMatch[1]) {
                    buildId = generalMatch[1];
                    console.log("Detected buildId using fallback method:", buildId);
                    return;
                }
                
                // Last resort - hardcoded value
                buildId = 'c6e446ooRSiDtyheLN4bL';
                console.warn("Using hardcoded buildId as fallback. This may not work if the site has been updated.");
                return;
            } catch (error) {
                console.error("Error detecting buildId:", error);
                
                // Last resort - hardcoded value
                buildId = 'c6e446ooRSiDtyheLN4bL';
                console.warn("Using hardcoded buildId as fallback after error. This may not work if the site has been updated.");
            }
        }
        
        async function fetchAllSnippets() {
            updateProgress(0);
            allSnippets = [];
            loadedPages = 0;
            let fetchSuccess = false;
            
            // First try page 1 to see if we can get the data structure
            try {
                const page1Snippets = await fetchSnippetsPage(1);
                if (page1Snippets && page1Snippets.length > 0) {
                    fetchSuccess = true;
                    updateProgress((1 / totalPages) * 100);
                    
                    // Continue with other pages
                    for (let page = 2; page <= totalPages; page++) {
                        try {
                            await fetchSnippetsPage(page);
                        } catch (error) {
                            console.error(`Error fetching page ${page}:`, error);
                            // Continue with other pages even if one fails
                        }
                        updateProgress((loadedPages / totalPages) * 100);
                    }
                } else {
                    throw new Error("Could not retrieve snippets from page 1");
                }
            } catch (error) {
                console.error("Error starting snippet fetch:", error);
                loadingTextElement.textContent = `Error: ${error.message}. Check console for details.`;
                progressBarElement.style.backgroundColor = "#e53e3e";
                // Wait 5 seconds then hide the error
                setTimeout(() => {
                    showLoading(false);
                }, 5000);
                return;
            }
            
            if (allSnippets.length === 0) {
                loadingTextElement.textContent = "Error: Could not find any snippets. The site structure may have changed.";
                progressBarElement.style.backgroundColor = "#e53e3e";
                // Wait 5 seconds then hide the error
                setTimeout(() => {
                    showLoading(false);
                }, 5000);
                return;
            }
            
            console.log(`Successfully loaded ${allSnippets.length} total snippets.`);
            
            // Extract all unique tags
            allTags = new Set();
            allSnippets.forEach(snippet => {
                if (snippet.tags && Array.isArray(snippet.tags)) {
                    snippet.tags.forEach(tag => allTags.add(tag));
                }
            });
            
            // Populate tags filter
            populateTagsFilter();
            
            showLoading(false);
            
            // Initial display without filtering
            filteredSnippets = [...allSnippets];
            displaySnippets(filteredSnippets);
        }

        async function fetchSnippetsPage(page) {
            const targetUrl = `https://duckdbsnippets.com/_next/data/${buildId}/page/${page}/most-recent.json?params=page&params=${page}&params=most-recent`;
            const url = `${PROXY_URL}?url=${encodeURIComponent(targetUrl)}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Debug logging to see the actual response structure
                console.log(`Page ${page} response structure:`, JSON.stringify(data).slice(0, 500) + '...');
                
                // Extract snippets from the response - handle different potential structures
                let pageSnippets = [];
                
                if (data.pageProps?.snippets?.data && Array.isArray(data.pageProps.snippets.data)) {
                    // This is the correct path based on the actual structure
                    pageSnippets = data.pageProps.snippets.data;
                } else if (data.pageProps?.snippets) {
                    // If snippets are directly in pageProps.snippets and it's an array
                    pageSnippets = Array.isArray(data.pageProps.snippets) ? data.pageProps.snippets : [];
                } else if (data.pageProps?.data?.snippets) {
                    // If snippets are nested in data
                    pageSnippets = data.pageProps.data.snippets;
                } else if (Array.isArray(data.pageProps)) {
                    // If pageProps itself is an array
                    pageSnippets = data.pageProps;
                } else if (Array.isArray(data)) {
                    // If data itself is an array
                    pageSnippets = data;
                } else {
                    // Last resort: look for any array in the response
                    for (const key in data) {
                        if (Array.isArray(data[key])) {
                            pageSnippets = data[key];
                            break;
                        }
                        
                        if (data[key] && typeof data[key] === 'object') {
                            for (const nestedKey in data[key]) {
                                if (Array.isArray(data[key][nestedKey])) {
                                    pageSnippets = data[key][nestedKey];
                                    break;
                                }
                                
                                // Add one more level of nesting check
                                if (data[key][nestedKey] && typeof data[key][nestedKey] === 'object') {
                                    for (const deepNestedKey in data[key][nestedKey]) {
                                        if (Array.isArray(data[key][nestedKey][deepNestedKey])) {
                                            pageSnippets = data[key][nestedKey][deepNestedKey];
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (!Array.isArray(pageSnippets)) {
                    console.error(`Could not find snippets array in page ${page} response`, data);
                    pageSnippets = [];
                }
                
                console.log(`Found ${pageSnippets.length} snippets on page ${page}`);
                
                // Add to our collection
                if (pageSnippets.length > 0) {
                    allSnippets = [...allSnippets, ...pageSnippets];
                }
                
                loadedPages++;
                loadingTextElement.textContent = `Loading snippets... (${loadedPages}/${totalPages})`;
                
                return pageSnippets;
            } catch (error) {
                console.error(`Error fetching page ${page}:`, error);
                throw error;
            }
        }

        function populateTagsFilter() {
            tagsContainerElement.innerHTML = '';
            
            // Sort tags alphabetically
            const sortedTags = Array.from(allTags).sort();
            
            sortedTags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag';
                tagElement.textContent = tag;
                tagElement.onclick = () => toggleTagFilter(tag, tagElement);
                tagsContainerElement.appendChild(tagElement);
            });
        }

        function toggleTagFilter(tag, element) {
            if (selectedTags.has(tag)) {
                selectedTags.delete(tag);
                element.classList.remove('selected');
            } else {
                selectedTags.add(tag);
                element.classList.add('selected');
            }
            
            // Re-apply filters
            applyFilters();
        }

        function searchSnippets() {
            applyFilters();
        }

        function applyFilters() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            
            filteredSnippets = allSnippets.filter(snippet => {
                // Apply search term filter
                let matchesSearch = true;
                if (searchTerm.trim()) {
                    const terms = searchTerm.split(' ').filter(term => term.length > 0);
                    
                    const title = snippet.title?.toLowerCase() || '';
                    const content = snippet.content?.toLowerCase() || '';
                    const tags = snippet.tags ? snippet.tags.join(' ').toLowerCase() : '';
                    
                    matchesSearch = terms.every(term => 
                        title.includes(term) || 
                        content.includes(term) || 
                        tags.includes(term)
                    );
                }
                
                // Apply tags filter
                let matchesTags = true;
                if (selectedTags.size > 0) {
                    matchesTags = selectedTags.size === 0 || 
                        (snippet.tags && Array.from(selectedTags).every(tag => snippet.tags.includes(tag)));
                }
                
                return matchesSearch && matchesTags;
            });
            
            displaySnippets(filteredSnippets);
        }

        function clearSearch() {
            document.getElementById('search').value = '';
            
            // Clear tag selections
            selectedTags.clear();
            document.querySelectorAll('#tags-container .tag').forEach(el => {
                el.classList.remove('selected');
            });
            
            filteredSnippets = [...allSnippets];
            displaySnippets(filteredSnippets);
        }

        function displaySnippets(snippets) {
            resultsElement.innerHTML = '';
            
            // Update stats
            statsElement.textContent = `Showing ${snippets.length} of ${allSnippets.length} snippets`;
            
            if (snippets.length === 0) {
                resultsElement.innerHTML = '<p>No snippets found. Try a different search term or tag filter.</p>';
                return;
            }
            
            snippets.forEach(snippet => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet';
                
                // Format date
                const dateStr = snippet.createdAt ? new Date(snippet.createdAt).toLocaleDateString() : 'Unknown date';
                
                // Tags
                const tagsHtml = snippet.tags ? 
                    snippet.tags.map(tag => `<span class="tag">${tag}</span>`).join('') : '';
                
                // Add copy button to code
                const copyBtnHtml = `<button class="copy-btn" onclick="copyToClipboard(this)">Copy</button>`;
                
                // Get code content - check multiple possible property names
                const codeContent = snippet.code || snippet.content || '';
                
                snippetDiv.innerHTML = `
                    <h3>${snippet.title}</h3>
                    <div class="meta">
                        <span>Created: ${dateStr}</span>
                        ${snippet.author ? ` by <strong>${snippet.author}</strong>` : ''}
                    </div>
                    <div>${tagsHtml}</div>
                    <pre><code>${copyBtnHtml}${codeContent}</code></pre>
                `;
                
                resultsElement.appendChild(snippetDiv);
            });
        }

        function copyToClipboard(button) {
            const codeElement = button.nextSibling;
            const textToCopy = codeElement.textContent;
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Temporarily change button text
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Could not copy text: ', err);
            });
        }

        function showLoading(show) {
            loadingElement.style.display = show ? 'block' : 'none';
        }

        function updateProgress(percent) {
            progressBarElement.style.width = `${percent}%`;
        }
    </script>
</body>
</html>